import random
import pygame, sys
import time

#ARRAYS RELATING TO RACETRACK DATA

#Base lap times for all drivers at each track
bhrLapTimeIdeal = [90.681,90.921,90.558,90.687,91.252,91.048,91.782,91.621,92.008,92.945,91.560,92.493,92.777,93.032,91.461,91.998,91.635,92.493,92.664,93.634]
ksaLapTimeIdeal = [88.461,88.200,88.225,88.402,89.104,90.343,89.068,89.147,89.651,89.773,89.183,89.819,90.543,90.256,89.546,89.920,89.418,90.415,90.492,91.817]
ausLapTimeIdeal = [78.154,78.240,77.868,78.469,78.933,78.825,79.061,78.815,78.703,79.032,79.251,79.910,81.149,80.611,80.254,80.104,79.226,79.424,80.135,81.372]
emiLapTimeIdeal = [78.793,79.296,78.796,78.990,79.457,79.992,81.179,79.595,79.294,79.980,80.192,79.730,79.957,80.342,79.902,80.422,80.732,80.474,80.591,81.338]
miaLapTimeIdeal = [88.991,89.036,88.796,88.986,90.173,89.625,90.861,90.160,89.634,90.310,89.475,91.020,90.214,89.996,90.975,90.423,89.960,89.932,91.266,91.325]
espLapTimeIdeal = [79.073,79.420,78.750,79.166,79.393,79.512,80.638,81.043,80.471,80.287,79.608,80.476,80.954,81.418,79.682,80.436,80.719,80.707,81.645,91.915]
monLapTimeIdeal = [71.666,71.629,71.376,71.629,72.112,72.560,72.528,72.247,71.849,72.964,72.909,74.861,72.613,73.678,72.921,73.081,73.660,72.797,73.611,74.403]
azeLapTimeIdeal = [101.706,101.641,101.359,101.814,102.712,102.924,103.585,103.173,103.398,103.574,104.444,103.777,103.091,104.879,104.643,105.532,102.845,103.056,104.719,105.367]
canLapTimeIdeal = [74.127,75.167,74.208,74.352,74.971,75.421,75.119,74.543,74.987,75.033,76.426,75.526,74.442,75.396,75.499,75.516,74.879,75.567,76.171,76.509]
gbrLapTimeIdeal = [87.901,88.311,88.348,88.689,88.426,88.488,89.553,89.510,89.102,90.293,89.185,89.752,89.593,89.892,90.523,89.510,89.885,90.039,89.780,90.489]
autLapTimeIdeal = [64.984,66.143,65.013,65.066,65.431,65.475,65.726,66.016,66.330,66.613,66.319,66.901,67.083,66.847,65.879,66.011,66.160,66.463,66.230,67.003]
fraLapTimeIdeal = [91.176,91.335,90.872,91.081,92.131,91.765,93.048,92.552,92.032,92.922,93.034,93.674,93.276,93.439,92.649,93.701,93.439,92.780,93.307,93.794]
hunLapTimeIdeal = [77.703,78.516,77.567,77.421,77.377,78.035,78.018,78.078,77.769,78.379,78.157,78.573,79.273,79.137,78.825,79.164,79.527,79.240,79.256,79.570]
belLapTimeIdeal = [103.665,104.462,104.551,104.297,105.461,105.420,105.180,105.368,105.603,105.767,106.881,106.085,106.344,106.256,106.557,106.342,105.827,106.692,105.672,106.401]
nedLapTimeIdeal = [70.342,71.077,70.363,70.434,71.147,70.648,71.605,71.613,71.174,72.081,71.961,71.704,72.391,71.416,72.319,71.420,71.427,71.512,71.695,73.353]
itaLapTimeIdeal = [80.306,81.206,80.161,80.429,81.542,81.524,82.130,81.861,81.584,81.855,82.235,82.003,82.636,82.748,82.908,83.005,82.010,82.020,82.471,82.587]
sinLapTimeIdeal = [102.926,103.906,102.795,102.587,102.911,103.033,103.412,103.520,104.013,105.447,103.431,104.524,104.429,103.982,104.422,105.623,104.469,105.211,105.144,106.533]
jpnLapTimeIdeal = [89.304,89.709,89.314,89.361,90.389,90.261,90.165,90.322,90.473,90.659,90.709,90.894,90.554,91.419,91.352,91.152,91.322,90.808,91.311,91.511]
usaLapTimeIdeal = [94.448,94.645,94.421,94.356,94.947,94.988,97.068,95.876,95.690,97.046,96.319,96.656,96.398,95.598,96.949,97.111,96.577,96.808,96.368,97.244]
mexLapTimeIdeal = [77.775,78.084,78.555,78.351,78.079,78.084,79.010,78.939,78.721,79.325,78.401,79.476,80.419,80.520,79.833,80.419,79.672,79.589,80.859,81.167]
braLapTimeIdeal = [70.881,71.456,70.950,70.890,71.318,71.539,71.587,71.394,71.377,72.140,72.466,73.115,71.678,72.210,71.410,72.314,71.675,73.347,71.631,73.019]
abdLapTimeIdeal = [83.324,84.025,84.092,84.242,84.511,84.508,84.830,85.096,84.769,85.045,85.892,85.408,84.961,85.359,85.834,85.225,85.859,85.219,86.028,86.054]

#Number of laps for each race
lapsPerRace = [57,50,58,63,57,66,78,51,70,52,71,53,70,44,72,53,61,52,56,71,71,58]

#Amount that it is raining and level of water that is on the track
rainLevel = 0
trackWater = 0

#Whether the race can be wet or not
dryRaceYesNo = True

#ARRAYS RELATING TO DRIVER DATA

#Driver names
driverName = ["M. Verstappen", "S. Perez", "C. Leclerc", "C. Sainz", "G. Russell", "L. Hamilton", "E. Ocon", "F. Alonso", "L. Norris", "D. Ricciardo", "V. Bottas", "Zhou G.", "S. Vettel", "L. Stroll", "K. Magnussen", "M. Schumacher", "P. Gasly", "Y. Tsunoda", "A. Albon", "N. Latifi"]
teamName = ["Red Bull", "Ferrari", "Mercedes", "Alpine", "McLaren", "Alfa Romeo", "Aston Martin", "Haas", "Alpha Tauri", "Williams"]

#Array for mistake coefficient
mistakeAttribute = [89,88,88,86,87,92,85,83,86,85,90,77,82,83,77,79,85,77,80,77]

#Arrays that store whether the driver in question has damage, and if so, whether that damage is minor or major
minorDamageList = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
majorDamageList = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#Time gain per lap due to lost fuel
fuelTimeGain = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#Tyre compound, and the time that they are losing compared to the softest compound with the most grip
tyreType = ["soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft","soft"]
#tyreType = ["hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard","hard"]
#tyreType = ["medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium","medium"]
tyreTimeLoss = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
stintLength = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#Ability to manage tyres successfully
tyreAttr = [78,82,84,79,93,85,83,90,83,96,81,83,94,86,84,88,79,85,88,80]

#Reactions
reactionsAttr = [84,87,91,77,92,88,85,89,78,82,83,78,89,75,77,75,80,70,79,78]

#Gaps between each driver, which driver each driver is directly behind, and the overall race standings
gapInFront = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]
gapBehind = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]
driverInFront = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
raceStandings = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]

#Last recorded lap time for each driver
lastLap = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#Whether a driver is pitting on this lap
pitThisLap = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]

#Fastest possible pitstop for each driver
optimalPitTime = [2.04,2.04,2.18,2.18,2.35,2.35,2.35,2.35,1.98,1.98,3.09,3.09,2.46,2.46,3.39,3.39,2.10,2.10,2.53,2.53]

#Whether a driver has retired or not
retirementArray = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]

#Heuristics for tyre degradation
softHeuristic = 0.1052150767
medHeuristic = 0.07709294989
hardHeuristic = 0.05884397507

#Qualifying
bestLap = [200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200]
orderedQualifying = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

#Championship standings
championshipStandings = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
constructorsStandings = [0,0,0,0,0,0,0,0,0,0]

carsLeft = 20

#ITERATION 1: SUBROUTINES STARTS HERE

#Subroutine that returns base lap time
def getIdealLapTime(raceNo, driverX):
    #Fetches from the correct array for the track that is currently being simulated
    if raceNo == 0:
        return bhrLapTimeIdeal[driverX]
    elif raceNo == 1:
        return ksaLapTimeIdeal[driverX]
    elif raceNo == 2:
        return ausLapTimeIdeal[driverX]
    elif raceNo == 3:
        return emiLapTimeIdeal[driverX]
    elif raceNo == 4:
        return miaLapTimeIdeal[driverX]
    elif raceNo == 5:
        return espLapTimeIdeal[driverX]
    elif raceNo == 6:
        return monLapTimeIdeal[driverX]
    elif raceNo == 7:
        return azeLapTimeIdeal[driverX]
    elif raceNo == 8:
        return canLapTimeIdeal[driverX]
    elif raceNo == 9:
        return gbrLapTimeIdeal[driverX]
    elif raceNo == 10:
        return autLapTimeIdeal[driverX]
    elif raceNo == 11:
        return fraLapTimeIdeal[driverX]
    elif raceNo == 12:
        return hunLapTimeIdeal[driverX]
    elif raceNo == 13:
        return belLapTimeIdeal[driverX]
    elif raceNo == 14:
        return nedLapTimeIdeal[driverX]
    elif raceNo == 15:
        return itaLapTimeIdeal[driverX]
    elif raceNo == 16:
        return sinLapTimeIdeal[driverX]
    elif raceNo == 17:
        return jpnLapTimeIdeal[driverX]
    elif raceNo == 18:
        return usaLapTimeIdeal[driverX]
    elif raceNo == 19:
        return mexLapTimeIdeal[driverX]
    elif raceNo == 20:
        return braLapTimeIdeal[driverX]
    elif raceNo == 21:
        return abdLapTimeIdeal[driverX]
    
#Mistake generator
def generateMistakeCoefficient(driverX):
    chanceOfMistake = mistakeAttribute[driverX]-10
    #chanceOfMistake determines how low the odds are of a driver making a mistake on a specific lap
    mistakeYesOrNo = random.randint(0,chanceOfMistake)
    #Whether a driver makes a mistake or not
    if mistakeYesOrNo == 0:
        mistakeType = random.randint(0,10)
        #Determines how the mistake will impact that driver's race
        if mistakeType < 4:
            return random.random() + 0.1
            #Minor mistake; loss of between 0-1 seconds on that lap alone
        elif mistakeType >=4 and mistakeType < 7:
            existingDamage = minorDamageList[driverX]
            minorDamageList[driverX] = existingDamage + random.random() + 0.1
            return minorDamageList[driverX]
        elif mistakeType == 7 or mistakeType == 8:
            existingDamage = majorDamageList[driverX]
            majorDamageList[driverX] = existingDamage + random.random() + 0.3
            return majorDamageList[driverX]
        elif mistakeType == 9:
            return retireFromRace(driverX, safetyCar, virtualSafetyCar,carsLeft)     
            #This calls a subroutine later on that will "retire" the driver from the race
        else:
            #Collision with another driver, if another driver is within 1 second of the car
            if gapInFront[driverX] < 1:
                mistakeType = random.randint(0,9)
                #Mistake type is re-randomised in order to see how much damage the car ahead receives
                if mistakeType < 4:
                    return random.random() + 0.1
                    #Minor incident between drivers with no damage received
                elif mistakeType >=4 and mistakeType < 7:
                    existingDamage = minorDamageList[driverInFront[driverX]]
                    minorDamageList[driverInFront[driverX]] = existingDamage + random.random() + 0.1
                    existingDamage = minorDamageList[driverX]
                    minorDamageList[driverX] = existingDamage + random.random() + 0.1
                    
                elif mistakeType == 7 or mistakeType == 8:
                    existingDamage = majorDamageList[driverInFront[driverX]]
                    majorDamageList[driverInFront[driverX]] = existingDamage + random.random() + 0.3
                    existingDamage = majorDamageList[driverX]
                    majorDamageList[driverX] = existingDamage + random.random() + 0.3
                    majorDamageList[driverX] = str(majorDamageList[driverX])
                    majorDamageList[driverInFront[driverX]] = str(majorDamageList[driverInFront[driverX]])
                    return majorDamageList[driverX] + majorDamageList[driverInFront[driverX]]
            else:
                return retireFromRace(driverX, safetyCar, virtualSafetyCar, carsLeft)
                #This calls a subroutine later on that will "retire" the driver from the race
    else:
        return "No error"

def generateFuelCoefficient(driverX,lapsRemaining,lap):
    if lap == 0:
        fuelTimeGain[driverX] = random.normalvariate(0.058,0.0125)
        if fuelTimeGain[driverX] < 0.035 or fuelTimeGain[driverX] > 0.08:
            fuelTimeGain[driverX] = 0.058
        return fuelTimeGain[driverX]*lapsRemaining
    return fuelTimeGain[driverX]*lapsRemaining


def generateTyreCoefficient(driverX):
    #Initialising time loss if the stint on the set of tyres has just started
    if stintLength[driverX] == 0:
        if tyreType[driverX] == "soft":
            tyreTimeLoss[driverX] = 0
        elif tyreType[driverX] == "medium":
            tyreTimeLoss[driverX] = 0.3
        elif tyreType[driverX] == "hard":
            tyreTimeLoss[driverX] = 0.85
    else:
        #Calculcating additional time for this lap from loss of tyre grip
        driverTyreManagementStat = tyreAttr[driverX] / 10000
        if tyreType[driverX] == "soft":
            tyreTimeLoss[driverX] = tyreTimeLoss[driverX] + random.normalvariate(0.12 - driverTyreManagementStat,0.015)
        elif tyreType[driverX] == "medium":
            tyreTimeLoss[driverX] = tyreTimeLoss[driverX] + random.normalvariate(0.09 - driverTyreManagementStat,0.01)
        elif tyreType[driverX] == "hard":
            tyreTimeLoss[driverX] = tyreTimeLoss[driverX] + random.normalvariate(0.07 - driverTyreManagementStat,0.0075)
    stintLength[driverX] = stintLength[driverX] + 1
    return tyreTimeLoss[driverX]
        

def generateWeatherCoefficient(dryRaceYesNo, trackWater):
    if dryRaceYesNo == True:
        return 1
        #No additional time lost for wet conditions, as track is dry
    else:
        timeLossMultiplier = trackWater + 1
        return timeLossMultiplier
    

def trackWaterDeterminer(trackWater, rainLevel, dryRaceYesNo):
    if rainLevel == 1:
      trackWater = trackWater - 0.03
      if trackWater < 0.03:
       trackWater = 0
       rainLevel = 3
       #Very low rain; track drying quickly
      chanceOfChange = random.randint(0,2)
    #Chance that the level of rain may change
      if chanceOfChange == 0:
        rainLevel = 2
    elif rainLevel == 2:
        #Low rain; track drying slowly
      trackWater = trackWater - 0.01
      if trackWater < 0.01:
        trackWater = 0
        rainLevel = 3
    #Rain level 3 is skipped due it representing no change to track water
    elif rainLevel == 4:
        if trackWater < 0.5:
            #Somewhat heavy rain; track getting wetter
            trackWater = trackWater + 0.01
    elif rainLevel == 5:
        if trackWater < 0.5:
            #Very heavy rain; track getting much wetter
            trackWater = trackWater + 0.03
    return trackWater


def rainLevelDeterminer(trackWater, rainLevel, dryRaceYesNo):
    if trackWater == 0:
        #Track dry, potential for no more rain
        chanceOfChange = random.randint(0,1)
        if chanceOfChange == 0:
            dryRaceYesNo = True
            return 0
    if dryRaceYesNo == True:
        return 0
    chanceOfChange = random.randint(0,4)
    #Randomly generated chance of there being a change in the amount of rainfall
    if chanceOfChange == 0:
        if rainLevel > 1:
            rainLevel = rainLevel - 1
            #Decrease in level of rainfall
    elif chanceOfChange == 4:
        if rainLevel < 5:
            rainLevel = rainLevel + 1
            #Increase in level of rainfall
    return rainLevel
    
def fetchDamageCoefficient(driverX):
    #Returns the total amount of damage on the car
    return float(minorDamageList[driverX]) + float(majorDamageList[driverX])

def generateStartCoefficient(driverX, lap):
    if lap == 1:
        for i in range (0,20):
            if i == 19 or i == 20:
                return 3
            elif raceStandings[i] == driverX:
                if raceStandings[driverX] == "blank":
                    retireFromRace(driverX, safetyCar, virtualSafetyCar, carsLeft)
                else:
                    return random.normalvariate(0.25,0.05)*float(raceStandings[driverX]) + (1-((reactionsAttr[driverX])/1000))
            
    else:
        return 0

def generateOvertakeAndDirtyAirCoefficient(driverX, safetyCar, virtualSafetyCar):
    allocationCheck = False
    if raceStandings[driverX] == 0:
        return 1
    for i in range(0,20):
        if raceStandings[i] == driverX:
            driverToBeOvertaken = raceStandings[i-1]
            validationCheck = False
            z = 2
            while validationCheck == False:
            #Determines which memory location to compare attributes from to the ones of driverX
                try:
                    #Attempts to convert the given input into an integer
                    driverToBeOvertaken = int(driverToBeOvertaken)
                    validationCheck = True
                except ValueError:
                    if driverX - z >=0:
                        driverToBeOvertaken = raceStandings[driverX-z]
                        z = z + 1
                    else:
                        retireFromRace(driverX, safetyCar, virtualSafetyCar,carsLeft)
                        return 0
                
                
            
            allocationCheck = True
    if allocationCheck == False:
            retireFromRace(driverX, safetyCar, virtualSafetyCar,carsLeft)
            return 0
    
    driverToBeOvertakenLapTime = (lastLap[driverToBeOvertaken])
    if safetyCar == True or virtualSafetyCar == True:
        return 1
    elif raceStandings[driverX] == "blank":
        return 1
    elif gapBehind[raceStandings[driverX]] == None:
        return 1
    elif gapBehind[raceStandings[driverX]] < 1:
        chance = random.randint(0,9)
        if chance == 9:
            if chance == 9:
                raceStandings[20] = raceStandings[driverX]
                raceStandings[driverX] = raceStandings[driverX - 1]
                raceStandings[driverX - 1] = raceStandings[20]
                raceStandings[20] = "blank"
                gapInFront[driverX] = 0.5
                #Swapping the positions of the two drivers
                return 1.02 #Multiplier for the lap time (due to time loss overtaking)
        #Check of lap time to determine likelihood of overtaking
        if lastLap[driverX] == driverToBeOvertakenLapTime:
            chance = random.randint(0,9)
            #If an overtake is generated or not
            if chance > 7:
                raceStandings[20] = raceStandings[driverX]
                raceStandings[driverX] = raceStandings[driverX - 1]
                raceStandings[driverX - 1] = raceStandings[20]
                raceStandings[20] = "blank"
                gapInFront[driverX] = 0.5
                #Swapping the positions of the two drivers
                return 1.02 #Multiplier for the lap time (due to time loss overtaking)
            else:
                return 1.04 #Multiplier for the lap time (due to time loss from dirty air)
        elif lastLap[driverX] <= (driverToBeOvertakenLapTime - 0.4):
            chance = random.randint(0,4)
            if chance > 2:
                raceStandings[20] = raceStandings[driverX]
                raceStandings[driverX] = raceStandings[driverX - 1]
                raceStandings[driverX - 1] = raceStandings[20]
                raceStandings[20] = "blank"
                gapInFront[driverX] = 0.5
                #Swapping the positions of the two drivers
                return 1.02
            else:
                return 1.04
        elif lastLap[driverX] <= (driverToBeOvertakenLapTime - 1):
            chance = random.randint(0,9)
            if chance != 9:
                raceStandings[20] = raceStandings[driverX]
                raceStandings[driverX] = raceStandings[driverX - 1]
                raceStandings[driverX - 1] = raceStandings[20]
                raceStandings[20] = "blank"
                #Swapping the positions of the two drivers
                return 1.02
            else:
                return 1.04
            
        else:
            return 1.04
    else:
      #If not near another car, multiplier of 1 is generated
      return 1

def generatePitCoefficient(driverX):
  if pitThisLap[driverX] == False:
      #Check if a driver is actually pitting
      return 0
  else:
    variance = random.random()
    #Generating variance (e.g. a driver stopping slightly out of place, reaction times etc)
    mistakeYesNo = random.randint(0,10)
    #Generating if there is a mistake
    if mistakeYesNo == 0:
      pitTime =  optimalPitTime[driverX] + variance + random.normalvariate(4,1) + 20
    else:
      pitTime = optimalPitTime[driverX] + variance + 20
  if minorDamageList[driverX] == 0:
    return pitTime
  else:
      #Adding time if there is damage that is fixable
    return pitTime + random.normalvariate(11,1.5)

#ITERATION 2

def retireFromRace(driverX, safetyCar, virtualSafetyCar, carsLeft):
    retirementArray[driverX] = True
    gapBehind[driverX] = 100
    gapInFront[driverX] = 100
    carsLeft = carsLeft - 1
    for i in range (0,20):
        if raceStandings[i] == driverX:
            for j in range (i,20):
                raceStandings[j] = raceStandings[j+1]
    safetyCarYesNo(safetyCar, virtualSafetyCar)
    return retirementArray[driverX]



def toPitOrNotToPit(driverX, raceNumber, lapsRemaining):
    if lapsRemaining < 0.1*lapsPerRace[raceNumber] and (safetyCar == False or virtualSafetyCar == False):
        return False
        #Preventing drivers from unnecessarily pitting if it is late in the race
    elif minorDamageList[driverX] > 0.25:
        return True
        #Making drivers with significant fixable damage pit
    elif stintLength[driverX] < 5:
        return False
    #Preventing drivers pitting unnecessarily when they have recently pitted
    elif tyreType[driverX] == "soft":
        #Different likelihoods of pitting depending on stint length
        if stintLength[driverX] > 0.15*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.3:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.2*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.5:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.25*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.7:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.35*lapsPerRace[raceNumber]:
             pitThisLap[driverX] = True
             #Automatically pitting after a certain point due to high tyre wear
        else:
            pitThisLap[driverX] = False
            #Returning false in case of no true value being generated
    elif tyreType[driverX] == "medium":
        #Different likelihoods of pitting depending on stint length
        if stintLength[driverX] > 0.35*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.3:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.4*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.5:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.45*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.7:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.5*lapsPerRace[raceNumber]:
             pitThisLap[driverX] = True
             #Automatically pitting after a certain point due to high tyre wear
        else:
            pitThisLap[driverX] = False
    elif tyreType[driverX] == "hard":
        if stintLength[driverX] > 0.5*lapsPerRace[raceNumber]:
            #Different likelihoods of pitting depending on stint length
            if random.normalvariate(0.5,0.2) < 0.3:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.55*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.5:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.6*lapsPerRace[raceNumber]:
            if random.normalvariate(0.5,0.2) < 0.7:
                pitThisLap[driverX] = True
        elif stintLength[driverX] > 0.7*lapsPerRace[raceNumber]:
             pitThisLap[driverX] = True
             #Automatically pitting after a certain point due to high tyre wear
        else:
            pitThisLap[driverX] = False
    return pitThisLap[driverX]
    

def determineNewCompound(lapsRemaining, raceNumber, softHeuristic, medHeuristic, hardHeuristic, driverX):
    if lapsRemaining < 0.2*lapsPerRace[raceNumber]:
        return "soft"
    softLoss = softHeuristic * lapsRemaining
    medLoss = medHeuristic * lapsRemaining
    hardLoss = hardHeuristic * lapsRemaining
    if softLoss < medLoss and softLoss < hardLoss:
        return "soft"
    elif softLoss/2 + softLoss/2 < medLoss:
        return "soft"
    elif medLoss < hardLoss:
        return "medium"
    elif medLoss*2/3 + softLoss*1/3 < hardLoss:
        return "medium"
    elif medLoss/2 + medLoss/2 < hardLoss:
        return "medium"
    elif tyreType[driverX] == "hard":
        return "medium"
    else:
        return "hard"


def mechanicalFailureGenerator(driverX):
  #Generates whether there will be a mechanical failure or not
  chance = random.randint(0,24959)
  if chance < 43:
    return retireFromRace(driverX, safetyCar, virtualSafetyCar,carsLeft)

#Generatinf whether there will be a safety car or not
def safetyCarYesNo(safetyCar, virtualSafetyCar):
  chance = random.randint(0,5)
  if chance == 0:
    safetyCar = True
  elif chance == 1 or chance == 2:
    virtualSafetyCar = True

#Correcting the distances between drivers
def distanceCorrection(driverX, safetyCar, virtualSafetyCar):
    driverFound = False
    for i in range (0,19):
        if raceStandings[i] == driverX:
            driverAhead = raceStandings[i-1]
            driverBehind = raceStandings[i+1]
            driverBehind = validateIntegerNoInput(driverBehind, driverX)
            driverFound = True
    if raceStandings[0] == driverX:
        gapInFront[driverX] = 100
    elif raceStandings[19] == driverX:
        gapBehind[driverX] = 100
    else:
        if driverFound == False:
            retireFromRace(driverX, safetyCar, virtualSafetyCar,carsLeft)
        elif driverBehind == "blank":
            gapBehind[driverX] = 100
        elif driverBehind < 0 or driverBehind > 19:
            gapBehind[driverX] = 3
        else:
            gapBehind[driverX] = float(gapInFront[driverBehind])
            aheadCorrection = lastLap[driverX] - lastLap[driverAhead]
            gapInFront[driverX] = gapInFront[driverX] + aheadCorrection
            if gapInFront[driverX] < 0:
                gapInFront[driverX] = 0.2
            elif gapInFront[driverX] > 120:
                gapInFront[driverX] = 120

def qualifying(raceNumber):
    for i in range(1,2):
        for driverX in range (0,20):
            chance = random.randint(0,1)
      #Each driver can either improve on their ideal lap or end up losing up to a second
            if chance == 0:
                newTime = getIdealLapTime(raceNumber, driverX) + random.random()
            else:
                newTime = getIdealLapTime(raceNumber, driverX) - (random.random()/8)
        #Storing the new lap time if it is better than the best previously set by a driver
            if bestLap[driverX] > newTime:
                bestLap[driverX] = newTime
                lastLap[driverX] = newTime

    for j in range(0,20):
        bestLap[j] = float(bestLap[j])
        orderedQualifying[j] = bestLap[j]
    for x in range (0,19):
        for y in range (0,19):
            if orderedQualifying[y-1] > orderedQualifying[y]:
                orderedQualifying[20] = orderedQualifying[y-1]
                orderedQualifying[y-1] = orderedQualifying[y]
                orderedQualifying[y] = orderedQualifying[20]
    

    for z in range (0,20):
        for w in range (0,20):
            if bestLap[z] == orderedQualifying[w]:
                raceStandings[w] = z




def fastestLapCheck(lap, fastestLap):
    if fastestLap > lap:
        return True
        #Main program changes the driverSetFastestLap variable
    else:
        return False
        

def allocatePoints(driverSetFastestLap):
    for i in range(0,10):
        j = raceStandings[i]
        if driverSetFastestLap == j:
            #Checks to see if a driver has set the fastest lap
            championshipStandings[j] = championshipStandings[j] + 1
        #Allocates points depending on the position of the driver
        if i == 0:
            championshipStandings[j] = championshipStandings[j] + 25
        elif i == 1:
          championshipStandings[j] = championshipStandings[j] + 18
        elif i == 2:
          championshipStandings[j] = championshipStandings[j] + 15
        elif i == 3:
          championshipStandings[j] = championshipStandings[j] + 12
        elif i == 4:
          championshipStandings[j] = championshipStandings[j] + 10
        elif i == 5:
          championshipStandings[j] = championshipStandings[j] + 8
        elif i == 6:
          championshipStandings[j] = championshipStandings[j] + 6
        elif i == 7:
          championshipStandings[j] = championshipStandings[j] + 4
        elif i == 8:
          championshipStandings[j] = championshipStandings[j] + 2
        else:
          championshipStandings[j] = championshipStandings[j] + 1
    for i in range(0,9):
        constructorsStandings[i] = championshipStandings[((i+1)*2)-1] + championshipStandings[((i+1)*2)-2]

#
def setDriver():
    inputted = input("Please input a number between 0 and 19. This determines the driver you will be editing")
    #Checking to see if the user has inputted a valid integer
    inputted = validateInteger(inputted)
    inputted = int(inputted)
            
    #Checking the integer is of valid length
    while inputted < 0 or inputted > 19:
        inputted = input("Please input a number between 0 and 19. This determines the driver you will be editing")
        validateInteger(inputted)
    driverName[inputted] = input("Please input the driver's name")
    #Checking name is of valid length
    while len(driverName[inputted]) > 30:
        driverName[inputted] = input("Please input the driver's name. Do not input anything over 30 characters long)")

    mistakeAttribute[inputted] = input("Please input the driver's mistakes stat. This is usually between 70 and 90")
    mistakeAttribute[inputted] = validateInteger(mistakeAttribute[inputted])
    
    reactionsAttr[inputted] = input("Please input the driver's reactions stat. This is usually between 70 and 90")
    reactionsAttr[inputted] = validateInteger(reactionsAttr[inputted])

    lapTimeChange = input("Please insert the mean time difference between this driver and his teammate (include +/-)")
    lapTimeChange = validateFloat(lapTimeChange)
    lapTimeChange = float(lapTimeChange)
    updateLapTimes(lapTimeChange, inputted)

def validateInteger(inputted):
    validationCheck = False
    while validationCheck == False:
        try:
            #Attempts to convert the given input into an integer
            inputted = int(inputted)
            validationCheck = True
        except ValueError:
            inputted = input("Please input an integer")
    return inputted

def validateIntegerNoInput(inputted, driverX):
    z = 2
    validationCheck = False
    while validationCheck == False:
        try:
            #Attempts to convert the given input into an integer
            inputted = int(inputted)
            
        except ValueError:
            if driverX + z <=20:
                inputted = raceStandings[driverX+z]
                z = z + 1
            else:
                return 20
        validationCheck = True
    return inputted


def validateFloat(inputted):
    validationCheck = False
    while validationCheck == False:
        try:
            #Attempts to convert the given input into a float
            inputted = float(inputted)
            validationCheck = True
        except ValueError:
            inputted = input("Please input a float")
    return inputted

def updateLapTimes(lapTimeChange, inputted):
    if inputted % 2 == 0:
        teammate = inputted + 1
    else:
        teammate = inputted - 1
    for raceNo in range (0,21):
        if raceNo == 0:
            bhrLapTimeIdeal[inputted] = bhrLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 1:
            ksaLapTimeIdeal[inputted] = ksaLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 2:
            ausLapTimeIdeal[inputted] = ausLapTimeIdeal[teammate]  + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 3:
            emiLapTimeIdeal[inputted] = emiLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 4:
            miaLapTimeIdeal[inputted] = miaLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 5:
            espLapTimeIdeal[inputted] = espLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 6:
            monLapTimeIdeal[inputted] = monLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 7:
            azeLapTimeIdeal[inputted] = azeLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 8:
            canLapTimeIdeal[inputted] = canLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 9:
            gbrLapTimeIdeal[inputted] = gbrLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 10:
            autLapTimeIdeal[inputted] = autLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 11:
            fraLapTimeIdeal[inputted] = fraLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 12:
            hunLapTimeIdeal[inputted] = hunLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 13:
            belLapTimeIdeal[inputted] = belLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 14:
            nedLapTimeIdeal[inputted] = nedLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 15:
            itaLapTimeIdeal[inputted] = itaLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 16:
            sinLapTimeIdeal[inputted] = sinLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 17:
            jpnLapTimeIdeal[inputted] = jpnLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 18:
            usaLapTimeIdeal[inputted] = usaLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 19:
            mexLapTimeIdeal[inputted] = mexLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 20:
            braLapTimeIdeal[inputted] = braLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
        elif raceNo == 21:
            abdLapTimeIdeal[inputted] = abdLapTimeIdeal[teammate] + random.normalvariate(lapTimeChange,0.2)
    
            
    
def setTrackWater(trackWater):
    trackWater = input("Input the level of track water. This should be a float between 0 and 0.3")
    trackWater = validateFloat(trackWater)
    trackWater = float(trackWater)
    while trackWater < 0 or trackWater > 0.3:
        trackWater = input("Value outside acceptable range. Please try again")
        validateFloat(trackWater)
    return trackWater

def setRainLevel(rainType):
    rainType = input("Input the level of rain. This should be an integer between 1 and 5")
    rainType = validateInteger(rainType)
    rainType = int(rainType)
    while rainType < 1 or rainType > 5:
        rainType = input("Value outside acceptable range. Please try again")
        validateInteger(rainType)
    return rainType

    


def race(raceNumber, fastestLap, driverSetFastestLap, safetyCar, virtualSafetyCar, trackWater, rainLevel, dryRaceYesNo, championshipMode):
    for a in range (0,20):
        gapBehind[a] = 0.5
        gapInFront[a] = 0.5
    
    lapsPerRace[0] = 57
    for i in range (0,lapsPerRace[raceNumber]):
        if raceNumber == 0:
            if i == 50:
                lapsPerRace[raceNumber] = lapsPerRace[raceNumber] + 7
        #Iteration for every lap in the race
        lapsRemaining = lapsPerRace[raceNumber] - i
        for j in range (0,20):
            #Iteration for every driver participating in the race
            if retirementArray[j] == False:
                if safetyCar == True:
                    #Safety car lap times
                    lapTime = getIdealLapTime(raceNumber,0) + 40
                    if raceStandings[0] == j:
                        gapBehind[j] = 0.5
                    elif raceStandings[19] == j:
                        gapInFront[j] = 0.5
                    else:
                        gapInFront[j] = 0.5
                        gapBehind[j] = 0.5
                elif virtualSafetyCar == True:
                    #VSC lap times
                    lapTime = getIdealLapTime(raceNumber,0)*1.35
                    lastLap[j] = lapTime
                else:
                    #Generates if there is a mechanical failure or not
                    mechanicalFailureGenerator(j)
                    #Generates the next compound to switch to if they are pitting or not
                    if pitThisLap[j] == True:
                        tyreType[j] = determineNewCompound(lapsRemaining, raceNumber, softHeuristic, medHeuristic, hardHeuristic, j)
                        stintLength[j] = 0
                        pitThisLap[j] = False
                    #Calculating the lap time based on all variables
                    lapTime = getIdealLapTime(raceNumber, j) + generateFuelCoefficient(j,lapsRemaining,i) + generateTyreCoefficient(j) + generateStartCoefficient(j, i)
                    lapTime = lapTime + generatePitCoefficient(j) + fetchDamageCoefficient(j)
                    lapTime = lapTime * generateOvertakeAndDirtyAirCoefficient(j,safetyCar,virtualSafetyCar)
                    #Generating any changes to track conditions
                    trackWater = trackWaterDeterminer(trackWater, rainLevel, dryRaceYesNo)
                    rainLevel = rainLevelDeterminer(trackWater, rainLevel, dryRaceYesNo)
                    lapTime = lapTime * generateWeatherCoefficient(dryRaceYesNo, trackWater)
                    #Storing the last lap the driver set in the lastLap array (needed for overtakeCoefficient)
                    lastLap[j] = float(lapTime)
                    #Corrects the distances to the car ahead
                    distanceCorrection(j, safetyCar, virtualSafetyCar)
                    #Outputs various important bits and bobs
                    
                    lapCheck = fastestLapCheck(lapTime, fastestLap)
                    #Checking if a driver set fastest lap; updates for fastest lap below
                    if lapCheck == True:
                        fastestLap = lapTime
                        driverSetFastestLap = j
                    pitThisLap[j] = toPitOrNotToPit(j, raceNumber, lapsRemaining)
        time.sleep(0.25)
        #Stopping the subroutine in order to let the viewer more easily see what is going on
        screen.fill((105,105,105))
        draw_text("Laps: " + str(i+1), bigFont, (255,255,255), screen, 700,50)
        #Displaying lap count
        for l in range (0,carsLeft):
            if raceStandings[l] == "blank":
                l = carsLeft
            else:
                nameAndTime = str(l+1) + ". " + driverName[int(raceStandings[l])]  +str(gapInFront[raceStandings[l]])
            draw_text(nameAndTime, bigFont, (255,255,255), screen, 100, (80+(20*(l-1))))
        

            #Outputting the race standings

        pygame.display.update()
        mainClock.tick(60)
        
        
        if safetyCar == True:
            safetyCarLapCounter = safetyCarLapCounter + 1
            if safetyCarLapCounter > 3:
                #Random chance of early safety car ending
                chanceOfEnding = random.normalvariate(0.5,0.25)
                if chanceOfEnding > 0.5:
                    safetyCar = False
            elif safetyCarLapCounter > 5:
                #Automatically ending safety car if laps completed is greater than 5
                safetyCar = False
        elif virtualSafetyCar == True:
            vscLapCounter = vscLapCounter + 1
            if vscLapCounter > 2:
                #Automatically ending VSC if laps completed is greater than 2
                virtualSafetyCar = False
    if championshipMode == True:
        allocatePoints(driverSetFastestLap)
        raceNumber = raceNumber + 1
    for a in range (0,20):
        gapBehind[a] = 0.5
        gapInFront[a] = 0.5
    reset()

                
    
#MAIN BELOW 

fastestLap = 2000
driverSetFastestLap = 20
total = 0
raceNumber = 0
if dryRaceYesNo == True:
    trackWater = 0
    rainLevel = 1
trackWater = 0
rainLevel = 0
dryRaceYesNo = True
safetyCar = False
virtualSafetyCar = False
safetyCarLapCounter = 0
vscLapCounter = 0
championshipMode = True

#allocatePoints(driverSetFastestLap)
#for y in range(0,20):
#    print(driverName[y] + " " + str(championshipStandings[y]))
#for z in range(0,10):
 #   print(teamName[z] + " " + str(constructorsStandings[z]))

def reset():
    fastestLap = 2000
    driverSetFastestLap = 20
    tyreTimeLoss = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    stintLength = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    retirementArray = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]
    gapInFront = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]
    gapBehind = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]







    
    


#UI



mainClock = pygame.time.Clock()
from pygame.locals import *
pygame.init()
pygame.display.set_caption("Formula 1 race simulator")
screen = pygame.display.set_mode((1280,720),0,32)

click = False

bigFont = pygame.font.SysFont(None, 30)
smallFont = pygame.font.SysFont(None, 25)

userText = ""

def draw_text(text, font, color, surface, x, y):
    textobj = font.render(text, 1, color)
    textrect = textobj.get_rect()
    textrect.topleft = (x,y)
    surface.blit(textobj, textrect)

def main_menu(raceNumber, championshipMode):
    click = False
    while True:
        #Background colour
        screen.fill((105,105,105))
        #Menu title
        draw_text("Main Menu", bigFont, (255,255,255), screen, 590, 20)
        #Detecting where the mouse is
        mx, my = pygame.mouse.get_pos()

        #Defining the buttons
        button1 = pygame.Rect(480,100,300,100)
        button2 = pygame.Rect(480,300,300,100)
        button3 = pygame.Rect(480,500,300,100)

        

        #Drawing the buttons
        pygame.draw.rect(screen, (255,0,0), button1)
        pygame.draw.rect(screen, (255,0,0), button2)
        pygame.draw.rect(screen, (255,0,0), button3)

        #Displaying text on the buttons
        draw_text("Race", bigFont, (255,255,255), screen, 590, 140)
        draw_text("Customise", bigFont, (255,255,255), screen, 580, 340)
        draw_text("Quit", bigFont, (255,255,255), screen, 590, 540)
        click = False
        
        for event in pygame.event.get():
            #Defining when to shut the program/register a click
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True
        #Displaying changes in the UI
        #Defining what happens if the buttons are clicked
        if button1.collidepoint(mx,my):
            if click:
                simMenu(raceNumber, championshipMode)
        if button2.collidepoint(mx,my):
            if click:
                customiseMenu()
        if button3.collidepoint(mx,my):
            if click:
                pygame.quit()
                sys.exit()
        pygame.display.update()
        mainClock.tick(60)

def simMenu(raceNumber, championshipMode):
    running = True
    click = False
    while running:
        
        mx, my = pygame.mouse.get_pos()
        screen.fill((105,105,105))
        button1 = pygame.Rect(480,100,300,100)
        button2 = pygame.Rect(480,300,300,100)
        
        if button1.collidepoint(mx,my):
            if click:
                raceSelectMenu()
        if button2.collidepoint(mx,my):
            if click:
                championshipMenu(championshipMode, raceNumber)
        pygame.draw.rect(screen, (255,0,0), button1)
        pygame.draw.rect(screen, (255,0,0), button2)
        draw_text("Single Race", bigFont, (255,255,255), screen, 580, 140)
        draw_text("Championship", bigFont, (255,255,255), screen, 580, 340)
        draw_text("Select Mode", bigFont, (255,255,255), screen, 590,20)
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
               if event.key == K_ESCAPE:
                    running = False
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True

        pygame.display.update()
        mainClock.tick(60)



def customiseMenu():
    running = True
    click = False
    
    while running:
        mx, my = pygame.mouse.get_pos()
        screen.fill((105,105,105))
        draw_text("Customise", bigFont, (255,255,255), screen, 590, 20)
        button1 = pygame.Rect(480,100,300,100)
        button2 = pygame.Rect(480,300,300,100)
        if button1.collidepoint(mx,my):
                if click:
                    setDriver()
                    simMenu(raceNumber, championshipMode)
        if button2.collidepoint(mx,my):
                if click:
                    setTrackWater(trackWater)
                    setRainLevel(rainLevel)
                    simMenu(championshipMode)
        pygame.draw.rect(screen, (255,0,0), button1)
        pygame.draw.rect(screen, (255,0,0), button2)
        draw_text("Driver", bigFont, (255,255,255), screen, 590,140)
        draw_text("Weather", bigFont, (255,255,255), screen, 590,340)
        
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
               if event.key == K_ESCAPE:
                    running = False
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True

        pygame.display.update()
        mainClock.tick(60)
        


def championshipMenu(championshipMode, raceNumber):
    gapInFront = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]
    gapBehind = [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5]
    raceNumber = raceNumber + 1
    reset()
    running = True
    click = False
    championshipMode = True
    while running:
        mx, my = pygame.mouse.get_pos()
        screen.fill((105,105,105))
        draw_text("Championship Mode!", bigFont, (255,255,255), screen, 540, 20)
        for l in range (0,20):
            nameAndPoints = str(l+1) + ". " + driverName[l] + " " + str(championshipStandings[l])
            draw_text(nameAndPoints, bigFont, (255,255,255), screen, 100, (80+(20*(l-1))))
        for m in range (0,10):
            nameAndPoints = str(m+1) + ". " + teamName[m] + " " + str(constructorsStandings[m])
            draw_text(nameAndPoints, bigFont, (255,255,255), screen, 1000, (80+(20*(m-1))))
        button1 = pygame.Rect(480,100,300,100)

        if button1.collidepoint(mx,my):
                if click:
                    raceScreen(championshipMode)
        pygame.draw.rect(screen, (255,0,0), button1)
        draw_text("Next Race", bigFont, (255,255,255), screen, 590,140)       
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
               if event.key == K_ESCAPE:
                    running = False
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True

        pygame.display.update()
        mainClock.tick(60)

def raceSelectMenu():
    running = True
    click = False
    
    while running:
        mx, my = pygame.mouse.get_pos()
        screen.fill((105,105,105))
        #Title of menu
        draw_text("Select Race", bigFont, (255,255,255), screen, 590, 20)
        #Defining the positions of the buttons
        button1 = pygame.Rect(50,100,200,50)
        button2 = pygame.Rect(300,100,200,50)
        button3 = pygame.Rect(550,100,200,50)
        button4 = pygame.Rect(800,100,200,50)
        button5 = pygame.Rect(1050,100,200,50)
        button6 = pygame.Rect(50,200,200,50)
        button7 = pygame.Rect(300,200,200,50)
        button8 = pygame.Rect(550,200,200,50)
        button9 = pygame.Rect(800,200,200,50)
        button10 = pygame.Rect(1050,200,200,50)
        button11 = pygame.Rect(50,300,200,50)
        button12 = pygame.Rect(300,300,200,50)
        button13 = pygame.Rect(550,300,200,50)
        button14 = pygame.Rect(800,300,200,50)
        button15 = pygame.Rect(1050,300,200,50)
        button16 = pygame.Rect(50,400,200,50)
        button17 = pygame.Rect(300,400,200,50)
        button18 = pygame.Rect(550,400,200,50)
        button19 = pygame.Rect(800,400,200,50)
        button20 = pygame.Rect(1050,400,200,50)
        button21 = pygame.Rect(400,500,200,50)
        button22 = pygame.Rect(700,500,200,50)
        
        #Displaying the buttons
        pygame.draw.rect(screen, (255,0,0), button1)
        pygame.draw.rect(screen, (255,0,0), button2)
        pygame.draw.rect(screen, (255,0,0), button3)
        pygame.draw.rect(screen, (255,0,0), button4)
        pygame.draw.rect(screen, (255,0,0), button5)
        pygame.draw.rect(screen, (255,0,0), button6)
        pygame.draw.rect(screen, (255,0,0), button7)
        pygame.draw.rect(screen, (255,0,0), button8)
        pygame.draw.rect(screen, (255,0,0), button9)
        pygame.draw.rect(screen, (255,0,0), button10)
        pygame.draw.rect(screen, (255,0,0), button11)
        pygame.draw.rect(screen, (255,0,0), button12)
        pygame.draw.rect(screen, (255,0,0), button13)
        pygame.draw.rect(screen, (255,0,0), button14)
        pygame.draw.rect(screen, (255,0,0), button15)
        pygame.draw.rect(screen, (255,0,0), button16)
        pygame.draw.rect(screen, (255,0,0), button17)
        pygame.draw.rect(screen, (255,0,0), button18)
        pygame.draw.rect(screen, (255,0,0), button19)
        pygame.draw.rect(screen, (255,0,0), button20)
        pygame.draw.rect(screen, (255,0,0), button21)
        pygame.draw.rect(screen, (255,0,0), button22)
        

        draw_text("Bahrain", smallFont, (255,255,255), screen, 113, 117)
        draw_text("Saudi Arabia", smallFont, (255,255,255), screen, 343, 117)
        draw_text("Australia", smallFont, (255,255,255), screen, 608, 117)
        draw_text("Emilia Romagna", smallFont, (255,255,255), screen, 833, 117)
        draw_text("Miami", smallFont, (255,255,255), screen, 1123, 117)
        draw_text("Spain", smallFont, (255,255,255), screen, 123, 217)
        draw_text("Monaco", smallFont, (255,255,255), screen, 363, 217)
        draw_text("Azerbaijan", smallFont, (255,255,255), screen, 608, 217)
        draw_text("Canada", smallFont, (255,255,255), screen, 863, 217)
        draw_text("Britain", smallFont, (255,255,255), screen, 1113, 217)
        draw_text("Austria", smallFont, (255,255,255), screen, 113, 317)
        draw_text("France", smallFont, (255,255,255), screen, 373, 317)
        draw_text("Hungary", smallFont, (255,255,255), screen, 613, 317)
        draw_text("Belgium", smallFont, (255,255,255), screen, 863, 317)
        draw_text("Netherlands", smallFont, (255,255,255), screen, 1103, 317)
        draw_text("Italy", smallFont, (255,255,255), screen, 123, 417)
        draw_text("Singapore", smallFont, (255,255,255), screen, 363, 417)
        draw_text("Japan", smallFont, (255,255,255), screen, 618, 417)
        draw_text("USA", smallFont, (255,255,255), screen, 873, 417)
        draw_text("Mexico", smallFont, (255,255,255), screen, 1113, 417)
        draw_text("Brazil", smallFont, (255,255,255), screen, 473, 517)
        draw_text("Abu Dhabi", smallFont, (255,255,255), screen, 753, 517)

        if button1.collidepoint(mx,my):
                if click:
                    raceScreen(0) 
        if button2.collidepoint(mx,my):
                if click:
                    raceScreen(1)
        if button3.collidepoint(mx,my):
                if click:
                    raceScreen(2)
        if button4.collidepoint(mx,my):
                if click:
                    raceScreen(3)
        if button5.collidepoint(mx,my):
                if click:
                    raceScreen(4)
        if button6.collidepoint(mx,my):
                if click:
                    raceScreen(5)
        if button7.collidepoint(mx,my):
                if click:
                    raceScreen(6)
        if button8.collidepoint(mx,my):
                if click:
                    raceScreen(7)
        if button9.collidepoint(mx,my):
                if click:
                    raceScreen(8)
        if button10.collidepoint(mx,my):
                if click:
                    raceScreen(9)
        if button11.collidepoint(mx,my):
                if click:
                    raceScreen(10)
        if button12.collidepoint(mx,my):
                if click:
                    raceScreen(11)
        if button13.collidepoint(mx,my):
                if click:
                    raceScreen(12)
        if button14.collidepoint(mx,my):
                if click:
                    raceScreen(13)
        if button15.collidepoint(mx,my):
                if click:
                    raceScreen(14)
        if button16.collidepoint(mx,my):
                if click:
                    raceScreen(15)
        if button17.collidepoint(mx,my):
                if click:
                    raceScreen(16)
        if button18.collidepoint(mx,my):
                if click:
                    raceScreen(17)
        if button19.collidepoint(mx,my):
                if click:
                    raceScreen(18)
        if button20.collidepoint(mx,my):
                if click:
                    raceScreen(19)
        if button21.collidepoint(mx,my):
                if click:
                    raceScreen(20)
        if button22.collidepoint(mx,my):
                if click:
                    raceScreen(21)
        

        
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
               if event.key == K_ESCAPE:
                    running = False
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True
        pygame.display.update()
        mainClock.tick(60)

def raceScreen(raceNumber):
    screen.fill((105,105,105))
    running = True
    click = False
    qualifying(raceNumber)
    draw_text("Standings:", bigFont, (255,255,255), screen, 100, 40)
    for i in range (0,20):
        if raceStandings[i] != "blank":
            nameAndTime = str(i+1) + ". " + driverName[raceStandings[i]] + str(orderedQualifying[i]) 
            draw_text(nameAndTime, bigFont, (255,255,255), screen, 100, (80+(20*(i-1))))

    while running:  
        mx, my = pygame.mouse.get_pos()
        
        button1 = pygame.Rect(480,100,300,100)
        pygame.draw.rect(screen, (255,0,0), button1)
        draw_text("Sim Race", bigFont, (255,255,255), screen, 580, 140)
        if button1.collidepoint(mx,my):
                if click:
                    interRaceScreen(raceNumber)
                    
        
        for event in pygame.event.get():

            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
               if event.key == K_ESCAPE:
                    running = False
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True

        pygame.display.update()
        mainClock.tick(60)
    
def interRaceScreen(raceNumber):
    screen.fill((105,105,105))
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()

            sys.exit()
    trueRaceScreen(raceNumber, championshipMode)
    pygame.display.update()
    mainClock.tick(60)

def trueRaceScreen(raceNumber, championshipMode):
    screen.fill((105,105,105))
    running = True
    click = False
    draw_text("Standings:", bigFont, (255,255,255), screen, 100, 40)
    race(raceNumber, fastestLap, driverSetFastestLap, safetyCar, virtualSafetyCar, trackWater, rainLevel, dryRaceYesNo, championshipMode)
    while running:
        for event in pygame.event.get():

            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            if event.type == KEYDOWN:
               if event.key == K_ESCAPE:
                   if championshipMode == True:
                       raceNumber = raceNumber + 1
                       championshipMenu(championshipMode, raceNumber)
                       
                   else:
                        main_menu()
            if event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    click = True

        pygame.display.update()
        mainClock.tick(60)

main_menu(raceNumber, championshipMode)
